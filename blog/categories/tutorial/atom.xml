<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tutorial | I'm Brian Chu]]></title>
  <link href="http://www.brianchu.com/blog/categories/tutorial/atom.xml" rel="self"/>
  <link href="http://www.brianchu.com/"/>
  <updated>2013-09-11T11:07:16-07:00</updated>
  <id>http://www.brianchu.com/</id>
  <author>
    <name><![CDATA[Brian Chu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An Interesting Module Pattern: the Sealed Module]]></title>
    <link href="http://www.brianchu.com/blog/2013/08/18/an-interesting-module-pattern-the-sealed-module/"/>
    <updated>2013-08-18T06:00:00-07:00</updated>
    <id>http://www.brianchu.com/blog/2013/08/18/an-interesting-module-pattern-the-sealed-module</id>
    <content type="html"><![CDATA[<p>An interesting way to share private state across components of modules in JavaScript: <!-- more --><br/>
(credit goes to <a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">this article</a>)</p>

<p>``` javascript
var module = (function (module) {
  var <em>private = module.</em>private = module.<em>private || {};
  var </em>seal = module.<em>seal = module.</em>seal || function () {</p>

<pre><code>delete module._private;
delete module._seal;
delete module._unseal;
</code></pre>

<p>  }
  var <em>unseal = module.</em>unseal = module._unseal || function () {</p>

<pre><code>module._private = _private;
module._seal = _seal;
module._unseal = _unseal;
</code></pre>

<p>  };
  // permanent access to <em>private, </em>seal, and _unseal</p>

<p>  return module;
}(module || {}));
```</p>

<p><code>_unseal</code> must be called by a function (probably some sort of loader function) that was initialized before <code>_seal</code> was called (so that <code>_unseal</code> will be present in its closure scope).</p>

<p>For example:</p>

<p>``` javascript
var loadScript = function (scriptUrl) {
  _unseal();
  var script = document.createElement(&lsquo;script&rsquo;);
  script.src = scriptUrl;</p>

<p>  if (script.readyState) {</p>

<pre><code>script.onreadystatechange = function () {
  if (script.readyState === "loaded" ||
      script.readyState === "complete") {
    script.onreadystatechange = null;
    module.seal();
  }
};
</code></pre>

<p>  }
  else {</p>

<pre><code>script.onload = function() {
  module.seal()
};
</code></pre>

<p>  }</p>

<p>  document.getElementsByTagName(&lsquo;head&rsquo;)[0].append(script);
};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt by Example - A Tutorial for JavaScript's Task Runner]]></title>
    <link href="http://www.brianchu.com/blog/2013/07/11/grunt-by-example-a-tutorial-for-javascripts-task-runner/"/>
    <updated>2013-07-11T16:35:00-07:00</updated>
    <id>http://www.brianchu.com/blog/2013/07/11/grunt-by-example-a-tutorial-for-javascripts-task-runner</id>
    <content type="html"><![CDATA[<p>What&rsquo;s Grunt used for? Automating front-end and JavaScript workflow tasks. Refreshing the browser when you change a script. Minifying and concatenating. Running tests. Think <code>rake</code> and <code>guard</code>, if you&rsquo;re coming from the Ruby world.</p>

<p>Enter Grunt by Example! A blow-by-blow tutorial. Just the way I like it. Let&rsquo;s dive in.</p>

<!-- more -->


<p>The catch &ndash; Grunt configuration files can be fairly convoluted at first glance, usually due to the fact that developers add more and more steps to their workflow over time.</p>

<p>Grunt is just a task runner. Every unit of functionality that you would want is usually achieved with a separate npm package (a grunt &ldquo;plugin&rdquo;).</p>

<p><code>npm search grunt</code> to view literally every grunt plugin available.</p>

<p>Get the command line interface: <code>npm install -g grunt-cli</code></p>

<p>Add the actual grunt task runner as a development dependency to your project (<code>--save-dev</code> adds the package as a dependency to <code>package.json</code>):
<code>npm install --save-dev grunt</code></p>

<p>Let&rsquo;s follow a process of gradual expansion.</p>

<p>Create an empty <code>Gruntfile.js</code> file in your project root. This will contain all of your task configuration.</p>

<p>Let&rsquo;s say that the first task we want to add to our workflow is to be able to concatenate several JavaScript files into one. Let&rsquo;s say those files are all in the <code>scripts/</code> sub-directory. We&rsquo;d want to do this before deploying a website, for example.</p>

<p>Run <code>npm install --save-dev grunt-contrib-concat</code>.</p>

<p>Let&rsquo;s look at our Gruntfile configured with just this one task.</p>

<p>A quick preview of the result before we look at the code. After setting up our configuration object, running <code>grunt concat</code>, <code>grunt concat:dist</code>, or <code>grunt build</code> in the shell in the project root will all do the same thing: concatenate all scripts in the <code>scripts</code> sub-directory into a single script called <code>main.js</code>.
``` javascript
//Grunt is just JavaScript running in node, after all&hellip;
module.exports = function(grunt) {</p>

<p>  // All upfront config goes in a massive nested object.
  grunt.initConfig({</p>

<pre><code>// You can set arbitrary key-value pairs.
distFolder: 'dist',
// You can also set the value of a key as parsed JSON.
// Allows us to reference properties we declared in package.json.
pkg: grunt.file.readJSON('package.json'),
// Grunt tasks are associated with specific properties.
// these names generally match their npm package name.
concat: {
  // Specify some options, usually specific to each plugin.
  options: {
    // Specifies string to be inserted between concatenated files.
    separator: ';'
  },
  // 'dist' is what is called a "target."
  // It's a way of specifying different sub-tasks or modes.
  dist: {
    // The files to concatenate:
    // Notice the wildcard, which is automatically expanded.
    src: ['scripts/*.js'],
    // The destination file:
    // Notice the angle-bracketed ERB-like templating,
    // which allows you to reference other properties.
    // This is equivalent to 'dist/main.js'.
    dest: '&lt;%= distFolder %&gt;/main.js'
    // You can reference any grunt config property you want.
    // Ex: '&lt;%= concat.options.separator %&gt;' instead of ';'
  }
}
</code></pre>

<p>  }); // The end of grunt.initConfig</p>

<p>  // We&rsquo;ve set up each task&rsquo;s configuration.
  // Now actually load the tasks.
  // This will do a lookup similar to node&rsquo;s require() function.
  grunt.loadNpmTasks(&lsquo;grunt-contrib-concat&rsquo;);</p>

<p>  // Register our own custom task alias.
  grunt.registerTask(&lsquo;build&rsquo;, [&lsquo;concat&rsquo;]);
};
```</p>

<p>You might still be confused about the notion of a &ldquo;target.&rdquo; More on that:</p>

<p>Let&rsquo;s say there&rsquo;s another set of files you want to concatenate. All script files in <code>deploy/</code> should be concatenated into <code>deploy.js</code> (in the project root). Let&rsquo;s say we want that task to look like <code>grunt concat:deploy</code></p>

<p>To achieve that, our concat task now looks like:</p>

<p>``` javascript</p>

<pre><code>concat: {
  options: {
    separator: ';'
  },
  dist: {
    src: ['scripts/*.js'],
    dest: '&lt;%= distFolder %&gt;/main.js'
  },
  deploy: {
    // options that are specific to the 'deploy' target
    // target-level options override task-level options
    options: {
      // separator:';;;' would override the parent setting
    },
    src:['deploy/*.js'],
    dest:'deploy.js'
  }
}
</code></pre>

<p>```</p>

<p>If you run <code>grunt concat:dist,</code> all scripts in <code>scripts/</code> will be concatenated into  <code>dist/main.js</code>. <code>grunt concat:dist</code> runs the concat task with the config settings that are specified under <code>dist</code>. <code>grunt concat:deploy</code> runs the concat task with the config settings specified under <code>deploy</code>. <code>grunt concat</code> will run concat with <em>both</em> targets, separately. The parent-level <code>options</code> setting specifies config settings that are shared by both targets. <code>grunt build</code> is an alias for <code>grunt concat</code>.</p>

<p>Now let&rsquo;s tackle a common, yet relatively complicated task.</p>

<p>Let&rsquo;s get Grunt to run certain tasks in response to changes in files. An extremely powerful and common use-case: reloading a static website when you change its HTML/CSS/JS. It&rsquo;s fairly complicated and it&rsquo;s usually something you just copy-and-paste. Here are the steps to setting this up using the <code>watch</code> and <code>connect</code> plugins, along with the <code>connect-livereload</code> (a piece of Connect middleware that is not grunt-specific). For this example, let&rsquo;s assume that your static website is located in the <code>client/</code> folder.</p>

<p>Install the three plugins:<br/>
<code>npm install --save-dev grunt-contrib-watch grunt-contrib-connect connect-livereload</code></p>

<p>Add this basic initialization code to the top of your Gruntfile:</p>

<p>``` javascript
// This is the default port that livereload listens on;
// change it if you configure livereload to use another port.
var LIVERELOAD_PORT = 35729;
// lrSnippet is just a function.
// It&rsquo;s a piece of Connect middleware that injects
// a script into the static served html.
var lrSnippet = require(&lsquo;connect-livereload&rsquo;)({ port: LIVERELOAD_PORT });
// All the middleware necessary to serve static files.
var livereloadMiddleware = function (connect, options) {
  return [</p>

<pre><code>// Inject a livereloading script into static files.
lrSnippet,
// Serve static files.
connect.static(options.base),
// Make empty directories browsable.
connect.directory(options.base)
</code></pre>

<p>  ];
};
```</p>

<p>Add to your grunt.initConfig object the following two tasks configurations:</p>

<p>``` javascript
// The connect task is used to serve static files with a local server.
connect: {
  client: {</p>

<pre><code>options: {
  // The server's port, and the folder to serve from:
  // Ex: 'localhost:9000' would serve up 'client/index.html'
  port: 9000,
  base:'client'
  // Custom middleware for the HTTP server:
  // The injected JavaScript reloads the page.
  middleware: livereloadMiddleware
}
</code></pre>

<p>  }
}
// The watch task is used to run tasks in response to file changes
watch: {
  client: {</p>

<pre><code>// '**' is used to include all subdirectories
// and subdirectories of subdirectories, and so on, recursively.
files: ['client/**/*'],
// In our case, we don't configure any additional tasks,
// since livereload is built into the watch task,
// and since the browser refresh is handled by the snippet.
// Any other tasks to run (e.g. compile CoffeeScript) go here:
tasks:[],
options: {
  livereload:LIVERELOAD_PORT
}
</code></pre>

<p>  }
}
```</p>

<p>Finally, we need to run the <code>connect</code> and <code>watch</code> tasks in sequence. To save ourselves from having to type in two shell commands, we can register a task alias:</p>

<p><code>javascript
grunt.registerTask('preview', ['connect:client','watch:client']);
</code></p>

<p>Running <code>grunt preview</code> will now run both tasks.</p>

<p>Some more grunt plugins to be aware about (<code>contrib</code> plugins are officially maintained):</p>

<ul>
<li><code>grunt-contrib-uglify</code> for minifying your JS files. It works similarly to <code>grunt-contrib-concat</code>.</li>
<li><code>grunt-contrib-jshint</code> for running JSHint.</li>
<li><code>grunt contrib-coffee</code> for compiling CoffeeScript.</li>
<li><code>grunt-contrib-sass</code> for compiling SASS.</li>
<li><code>grunt-concurrent</code> for running tasks concurrently (instead of sequentially) &ndash; useful if you want to run multiple watch tasks concurrently.

<ul>
<li>If you have a series of tasks, the <code>watch</code> task must be run last. <code>watch</code> is a task that never ends until you terminate it. Thus, Grunt won&rsquo;t ever reach tasks that come after <code>watch</code>.</li>
</ul>
</li>
<li><code>grunt-nodemon</code> for running <a href="https://github.com/remy/nodemon">nodemon</a> with your node app. This runs your node app and reloads it when files change.</li>
<li><code>grunt-simplemocha</code> for running mocha tests.</li>
<li><code>grunt-open</code> for opening files and URLs.</li>
</ul>


<p>Some tips:</p>

<ol>
<li>If your Gruntfile starts getting too unwieldy, you can break it up by using <code>grunt.file.readJSON()</code>.</li>
<li>Tired of copying and pasting <code>loadNpmTasks</code>?  Try this:

<ul>
<li><code>npm install --save-dev matchdep</code></li>
<li>use <code>require('matchdep').filterDev('grunt-*').forEach(grunt.loadNpmTasks);</code> where you would otherwise list out all your multiple <code>grunt.loadNpmTask</code> calls.</li>
</ul>
</li>
</ol>


<p>For more advanced concepts, <a href="http://gruntjs.com/getting-started">read the Grunt docs!</a> They&rsquo;re pretty good.</p>
]]></content>
  </entry>
  
</feed>
