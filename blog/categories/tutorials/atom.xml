<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tutorials | I'm Brian Chu]]></title>
  <link href="http://www.brianchu.com/blog/categories/tutorials/atom.xml" rel="self"/>
  <link href="http://www.brianchu.com/"/>
  <updated>2014-06-16T12:52:06-07:00</updated>
  <id>http://www.brianchu.com/</id>
  <author>
    <name><![CDATA[Brian Chu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating an Auto-Growing Text Input]]></title>
    <link href="http://www.brianchu.com/blog/2013/11/02/creating-an-auto-growing-text-input/"/>
    <updated>2013-11-02T12:00:00-07:00</updated>
    <id>http://www.brianchu.com/blog/2013/11/02/creating-an-auto-growing-text-input</id>
    
    <content type="html"><![CDATA[On two occasions I've encountered the same problem: how do you create a textarea that automatically expands along with your input. Here's an implementation.

<!-- more -->

This was inspired by some bits and pieces on StackOverflow. The gist of it is that you place your textarea inside a wrapper div, set the textarea height to 100% so that it fills the parent, and then insert a div behind the textarea that maintains a copy of the textarea text. The browser will correctly size the hidden div, which will stretch the parent and stretch the textarea.

Here's a jsFiddle:

<iframe width="100%" height="300" src="http://jsfiddle.net/2UDdh/43/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

A copy of the code is below:

``` html HTML
<div class="textarea-container">
  <textarea></textarea>
  <div class="textarea-size"></div>
</div>
```

``` css CSS
.textarea-container {
  position: relative;
  /* you should change this*/
  width: 50%;
}

textarea, .textarea-size {
  min-height: 25px;
  /* need to manually set font and font size */
  font-family: sans-serif;
  font-size: 14px;
  box-sizing: border-box;
  padding: 4px;
  border: 1px solid;

  overflow: hidden;
  width: 100%;
}

textarea {
  height: 100%;
  position: absolute;
  resize:none;

  /*
  "pre" or "preline" or "normal" fixes Chrome issue where
    whitespace at end of lines does not trigger a line break.
  However, it causes the text to exhibit the behavior seen with
    "pre" that is described below.
   */
  white-space: normal;
}

.textarea-size {
  visibility: hidden;

  /*
  Pre-wrap: preserve spacing and newlines, but wrap text.
  Pre: preserve spacing and newlines but don't wrap text.

  "pre" does not wrap well on Firefox, even with word-wrap:break-word.
  "pre" on Chrome works with word-wrap, but exhibits different behavior:
  Instead of entire words being moved to the next line for wrapping,
  the browser will cut words in the middle for wrapping.
  "pre-line" has Firefox issues
  */
  white-space: pre-wrap;
  /* Required for wrapping lines in Webkit,
    but not necessary in Firefox if you have white-space wrapping
    (pre-wrap, normal, pre-line) already set */
  word-wrap: break-word;
  overflow-wrap: break-word;
}
```

``` javascript JavaScript
var textContainer, textareaSize, input;
var autoSize = function () {
  // also can use textContent or innerText
  textareaSize.innerHTML = input.value + '\n';
};

document.addEventListener('DOMContentLoaded', function() {
  textContainer = document.querySelector('.textarea-container');
  textareaSize = textContainer.querySelector('.textarea-size');
  input = textContainer.querySelector('textarea');
  
  autoSize();
  input.addEventListener('input', autoSize);
});
```


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An Interesting Module Pattern: the Sealed Module]]></title>
    <link href="http://www.brianchu.com/blog/2013/08/18/an-interesting-module-pattern-the-sealed-module/"/>
    <updated>2013-08-18T06:00:00-07:00</updated>
    <id>http://www.brianchu.com/blog/2013/08/18/an-interesting-module-pattern-the-sealed-module</id>
    
    <content type="html"><![CDATA[An interesting way to share private state across components of modules in JavaScript: <!-- more -->  
(credit goes to [this article](http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html))

``` javascript
var module = (function (module) {
  var _private = module._private = module._private || {};
  var _seal = module._seal = module._seal || function () {
    delete module._private;
    delete module._seal;
    delete module._unseal;
  }
  var _unseal = module._unseal = module._unseal || function () {
    module._private = _private;
    module._seal = _seal;
    module._unseal = _unseal;
  };
  // permanent access to _private, _seal, and _unseal

  return module;
}(module || {}));
```

`_unseal` must be called by a function (probably some sort of loader function) that was initialized before `_seal` was called (so that `_unseal` will be present in its closure scope).

For example:

``` javascript
var loadScript = function (scriptUrl) {
  _unseal();
  var script = document.createElement('script');
  script.src = scriptUrl;

  if (script.readyState) {
    script.onreadystatechange = function () {
      if (script.readyState === "loaded" ||
          script.readyState === "complete") {
        script.onreadystatechange = null;
        module.seal();
      }
    };
  }
  else {
    script.onload = function() {
      module.seal()
    };
  }

  document.getElementsByTagName('head')[0].append(script);
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt by Example - A Tutorial for JavaScript's Task Runner]]></title>
    <link href="http://www.brianchu.com/blog/2013/07/11/grunt-by-example-a-tutorial-for-javascripts-task-runner/"/>
    <updated>2013-07-11T16:35:00-07:00</updated>
    <id>http://www.brianchu.com/blog/2013/07/11/grunt-by-example-a-tutorial-for-javascripts-task-runner</id>
    
    <content type="html"><![CDATA[What's Grunt used for? Automating front-end and JavaScript workflow tasks. Refreshing the browser when you change a script. Minifying and concatenating. Running tests. Think `rake` and `guard`, if you're coming from the Ruby world.

Enter Grunt by Example! A blow-by-blow tutorial. Just the way I like it. Let's dive in.

<!-- more -->

The catch - Grunt configuration files can be fairly convoluted at first glance, usually due to the fact that developers add more and more steps to their workflow over time.

Grunt is just a task runner. Every unit of functionality that you would want is usually achieved with a separate npm package (a grunt "plugin").

`npm search grunt` to view literally every grunt plugin available.

Get the command line interface: `npm install -g grunt-cli`

Add the actual grunt task runner as a development dependency to your project (`--save-dev` adds the package as a dependency to `package.json`):
`npm install --save-dev grunt`

Let's follow a process of gradual expansion.

Create an empty `Gruntfile.js` file in your project root. This will contain all of your task configuration.

Let's say that the first task we want to add to our workflow is to be able to concatenate several JavaScript files into one. Let's say those files are all in the `scripts/` sub-directory. We'd want to do this before deploying a website, for example.

Run `npm install --save-dev grunt-contrib-concat`.

Let's look at our Gruntfile configured with just this one task.

A quick preview of the result before we look at the code. After setting up our configuration object, running `grunt concat`, `grunt concat:dist`, or `grunt build` in the shell in the project root will all do the same thing: concatenate all scripts in the `scripts` sub-directory into a single script called `main.js`.
``` javascript
//Grunt is just JavaScript running in node, after all...
module.exports = function(grunt) {

  // All upfront config goes in a massive nested object.
  grunt.initConfig({
    // You can set arbitrary key-value pairs.
    distFolder: 'dist',
    // You can also set the value of a key as parsed JSON.
    // Allows us to reference properties we declared in package.json.
    pkg: grunt.file.readJSON('package.json'),
    // Grunt tasks are associated with specific properties.
    // these names generally match their npm package name.
    concat: {
      // Specify some options, usually specific to each plugin.
      options: {
        // Specifies string to be inserted between concatenated files.
        separator: ';'
      },
      // 'dist' is what is called a "target."
      // It's a way of specifying different sub-tasks or modes.
      dist: {
        // The files to concatenate:
        // Notice the wildcard, which is automatically expanded.
        src: ['scripts/*.js'],
        // The destination file:
        // Notice the angle-bracketed ERB-like templating,
        // which allows you to reference other properties.
        // This is equivalent to 'dist/main.js'.
        dest: '<%= distFolder %>/main.js'
        // You can reference any grunt config property you want.
        // Ex: '<%= concat.options.separator %>' instead of ';'
      }
    }
  }); // The end of grunt.initConfig

  // We've set up each task's configuration.
  // Now actually load the tasks.
  // This will do a lookup similar to node's require() function.
  grunt.loadNpmTasks('grunt-contrib-concat');

  // Register our own custom task alias.
  grunt.registerTask('build', ['concat']);
};
```

You might still be confused about the notion of a "target." More on that:

Let's say there's another set of files you want to concatenate. All script files in `deploy/` should be concatenated into `deploy.js` (in the project root). Let's say we want that task to look like `grunt concat:deploy`

To achieve that, our concat task now looks like:

``` javascript
    concat: {
      options: {
        separator: ';'
      },
      dist: {
        src: ['scripts/*.js'],
        dest: '<%= distFolder %>/main.js'
      },
      deploy: {
        // options that are specific to the 'deploy' target
        // target-level options override task-level options
        options: {
          // separator:';;;' would override the parent setting
        },
        src:['deploy/*.js'],
        dest:'deploy.js'
      }
    }
```

If you run `grunt concat:dist,` all scripts in `scripts/` will be concatenated into  `dist/main.js`. `grunt concat:dist` runs the concat task with the config settings that are specified under `dist`. `grunt concat:deploy` runs the concat task with the config settings specified under `deploy`. `grunt concat` will run concat with *both* targets, separately. The parent-level `options` setting specifies config settings that are shared by both targets. `grunt build` is an alias for `grunt concat`.

Now let's tackle a common, yet relatively complicated task.

Let's get Grunt to run certain tasks in response to changes in files. An extremely powerful and common use-case: reloading a static website when you change its HTML/CSS/JS. It's fairly complicated and it's usually something you just copy-and-paste. Here are the steps to setting this up using the `watch` and `connect` plugins, along with the `connect-livereload` (a piece of Connect middleware that is not grunt-specific). For this example, let's assume that your static website is located in the `client/` folder.

Install the three plugins:  
`npm install --save-dev grunt-contrib-watch grunt-contrib-connect connect-livereload`

Add this basic initialization code to the top of your Gruntfile:

``` javascript
// This is the default port that livereload listens on;
// change it if you configure livereload to use another port.
var LIVERELOAD_PORT = 35729;
// lrSnippet is just a function.
// It's a piece of Connect middleware that injects
// a script into the static served html.
var lrSnippet = require('connect-livereload')({ port: LIVERELOAD_PORT });
// All the middleware necessary to serve static files.
var livereloadMiddleware = function (connect, options) {
  return [
    // Inject a livereloading script into static files.
    lrSnippet,
    // Serve static files.
    connect.static(options.base),
    // Make empty directories browsable.
    connect.directory(options.base)
  ];
};
```

Add to your grunt.initConfig object the following two tasks configurations:

``` javascript
// The connect task is used to serve static files with a local server.
connect: {
  client: {
    options: {
      // The server's port, and the folder to serve from:
      // Ex: 'localhost:9000' would serve up 'client/index.html'
      port: 9000,
      base:'client'
      // Custom middleware for the HTTP server:
      // The injected JavaScript reloads the page.
      middleware: livereloadMiddleware
    }
  }
}
// The watch task is used to run tasks in response to file changes
watch: {
  client: {
    // '**' is used to include all subdirectories
    // and subdirectories of subdirectories, and so on, recursively.
    files: ['client/**/*'],
    // In our case, we don't configure any additional tasks,
    // since livereload is built into the watch task,
    // and since the browser refresh is handled by the snippet.
    // Any other tasks to run (e.g. compile CoffeeScript) go here:
    tasks:[],
    options: {
      livereload:LIVERELOAD_PORT
    }
  }
}
```

Finally, we need to run the `connect` and `watch` tasks in sequence. To save ourselves from having to type in two shell commands, we can register a task alias:

``` javascript
grunt.registerTask('preview', ['connect:client','watch:client']);
```

Running `grunt preview` will now run both tasks.

Some more grunt plugins to be aware about (`contrib` plugins are officially maintained):

* `grunt-contrib-uglify` for minifying your JS files. It works similarly to `grunt-contrib-concat`.
* `grunt-contrib-jshint` for running JSHint.
* `grunt contrib-coffee` for compiling CoffeeScript.
* `grunt-contrib-sass` for compiling SASS.
* `grunt-concurrent` for running tasks concurrently (instead of sequentially) - useful if you want to run multiple watch tasks concurrently.
  * If you have a series of tasks, the `watch` task must be run last. `watch` is a task that never ends until you terminate it. Thus, Grunt won't ever reach tasks that come after `watch`.
* `grunt-nodemon` for running [nodemon](https://github.com/remy/nodemon) with your node app. This runs your node app and reloads it when files change.
* `grunt-simplemocha` for running mocha tests.
* `grunt-open` for opening files and URLs.

Some tips:

1. If your Gruntfile starts getting too unwieldy, you can break it up by using `grunt.file.readJSON()`.
2. Tired of copying and pasting `loadNpmTasks`?  Try this:
    * `npm install --save-dev matchdep`
    * use `require('matchdep').filterDev('grunt-*').forEach(grunt.loadNpmTasks);` where you would otherwise list out all your multiple `grunt.loadNpmTask` calls.

For more advanced concepts, [read the Grunt docs!](http://gruntjs.com/getting-started) They're pretty good.]]></content>
  </entry>
  
</feed>
